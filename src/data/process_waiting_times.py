"""
Project: Phantasialand
State: 11/2021

Process a table containing waiting times that was generated by
`download_wartezeiten_app.py`. 

For OUTPUT_PATH, this script aggregates the datapoints for each half hour and removes all
datapoints between midnight and 1 AM (as the park is always closed at that time and
it only makes day-wise splitting of training data easier).  It also drops all 
datapoints with negative waiting time (i.e. when the park was closed).

The following columns are present in OUTPUT_PATH:
- id (int): unique id for each datapoint
- attraction (str): name of the attraction
- date (str): day in YYYY-MM-DD format
- half_hour_time (str): time rounded down to the nearest half hour
- waiting_time (int): waiting time in minutes (or negative if closed)

It is also possible to store an intermediate table that is neither aggregated nor 
filtered at EXPLORATION. It has the following columns: 

- id (int): unique id for each datapoint
- attraction (str): name of the attraction
- waiting_time (int): waiting time in minutes (or negative if closed)
- date (str): day in YYYY-MM-DD format
- time (str): time in HH:MM:SS format
- rounded_time (str): time rounded to the nearest five minutes.
"""


import datetime
import logging
from typing import Optional
import numpy as np

import pandas as pd
import click

from src.data.constants import LOGGING_FORMAT_STR


def round_time(time_str: str) -> str:
    """round a HH:MM:SS time string to nearest 5 minutes.

    Args:
        time_str (str): time string

    Returns:
        str: rounded time string in HH:MM:SS format (seconds are always 00)
    """
    t = datetime.time.fromisoformat(time_str)

    rounded_min = 5 * round((t.minute + t.second / 60) / 5)

    rounded_time = datetime.time(hour=t.hour, minute=rounded_min, second=0)

    return rounded_time.isoformat()


def round_half_hour(time: str) -> str:
    """round time down to the nearest half hour

    Args:
        time (str): time in the 'HH:MM:SS' format

    Returns:
        str: rounded time, either 'HH:30:00' or 'HH:00:00'
    """
    hours, mins, _ = time.split(":")

    if int(mins) < 30:
        return f"{hours}:00:00"
    else:
        return f"{hours}:30:00"


def assert_waiting_time_state_consistency(df: pd.DataFrame):
    """ensure that negative waiting times occur if and only if the attraction is closed.

    Args:
        df (pd.DataFrame): dataframe to check

    Raises:
        ValueError: raised if condition not fulfilled
    """

    if any((df.wartezeit >= 0) & ~(df.status == "opened")):
        raise ValueError(
            "cannot have nonnegative waiting time if the attraction is not opened"
        )

    if any((df.wartezeit < 0) & ~(df.status == "closed")):
        raise ValueError(
            "cannot have negative waiting time if the attraction is not closed"
        )


def transform_dataframe_exploration(df: pd.DataFrame) -> pd.DataFrame:
    """transform waiting times into the form used for explorative data analysis.

    There is no aggregation or filtering of datapoints, meaning there is one datapoint
    every five minutes.

    The following columns are present in the output:

    - id (int): unique id for each datapoint
    - attraction (str): name of the attraction
    - waiting_time (int): waiting time in minutes (or negative if closed)
    - date (str): day in YYYY-MM-DD format
    - time (str): time in HH:MM:SS format
    - rounded_time (str): time rounded to the nearest five minutes.

    Args:
        df (pd.DataFrame): raw waiting time data

    Returns:
        pd.DataFrame: waiting time data for exploration
    """

    df[["date", "time"]] = df.datum.str.split(" ", expand=True)
    df["rounded_time"] = df.time.apply(round_time)

    df.rename(columns={"datum": "timestamp", "wartezeit": "waiting_time"}, inplace=True)

    # drop as much columns as possible without loss of information
    df.drop(columns=["month", "year", "timestamp", "status"], inplace=True)

    return df


def transform_dataframe_training(waiting_time_df: pd.DataFrame) -> pd.DataFrame:
    """transform waiting times into the form used for model training.

    This function aggregates the datapoints for each half hour and removes all
    datapoints between midnight and 1 AM (as the park is always closed at that time and
    it only makes day-wise splitting of training data easier). It also drops all 
    datapoints with negative waiting time (i.e. when the park was closed).

    The following columns are present in the output:
    - id (int): unique id for each datapoint
    - attraction (str): name of the attraction
    - date (str): day in YYYY-MM-DD format
    - half_hour_time (str): time rounded down to the nearest half hour
    - waiting_time (int): waiting time in minutes (or negative if closed)

    Args:
        waiting_time_df (pd.DataFrame): DataFrame processed by
            `transform_dataframe_exploration`

    Returns:
        pd.DataFrame: aggregated waiting time data for training
    """

    # remove all entries past midnight. They are always -3 anyway (as the park closes
    # much earlier), so they just add more complexity without benefits
    waiting_time_df = waiting_time_df[
        ~waiting_time_df.time.str.startswith("00:")
    ].copy()
    waiting_time_df.waiting_time = waiting_time_df.waiting_time.map(
        lambda x: x if x >= 0 else np.nan
    )

    waiting_time_df["half_hour_time"] = waiting_time_df.time.apply(round_half_hour)
    waiting_time_half_hour_df = waiting_time_df.groupby(
        by=["attraction", "date", "half_hour_time"]
    ).agg("mean")
    waiting_time_half_hour_df.reset_index(inplace=True)
    waiting_time_half_hour_df.index.name = "id"

    # Drop datapoints where the park was closed
    waiting_time_half_hour_df.dropna(
        axis="index", how="any", subset=["waiting_time"], inplace=True
    )

    return waiting_time_half_hour_df


@click.command(help=__doc__)
@click.argument(
    "input_path", type=click.Path(exists=True)
)
@click.argument(
    "output_path",
    type=click.Path(),
)
@click.option(
    "--exploration",
    default=None,
    type=click.Path(),
    help="where to store the data in exploration format",
)
def main(input_path: str, output_path: str, exploration: Optional[str]):
    logging.basicConfig(format=LOGGING_FORMAT_STR, level=logging.INFO)

    df = pd.read_csv(input_path, index_col="id")

    assert_waiting_time_state_consistency(df)

    logging.info("Transforming dataframe for exploration...")
    df = transform_dataframe_exploration(df)

    if exploration:
        df.to_csv(exploration)

    logging.info("Transforming dataframe for training...")
    df = transform_dataframe_training(df)

    df.to_csv(output_path)

    logging.info("done")


if __name__ == "__main__":

    main()
